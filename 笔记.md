在编写路由组件前要先配置路由，在router文件夹中的index.js编写

路由组件与非路由组件区别：
    非路由组件放在components中，路由组件放在pages或views中
    非路由组件通过标签使用，路由组件通过路由使用
    在main.js注册玩路由，所有的路由和非路由组件身上都会拥有$router $route属性
    $router：一般进行编程式导航进行路由跳转
    $route： 一般获取路由信息（name path params等）

路由跳转有两种：
    声明式导航和编程式导航
    声明式路由导航通过<router-link></router-link>标签进行跳转，to属性设置跳转地址，tag属性设置解析模板时解析的标签，默认解析成a标签
    编程式路由导航通过js代码实现路由跳转，常用：
        this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)   ==>> 队列的方式（先进先出）
        this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)    ==>> 栈的方式（先进后出）
    当在跳转时要实现其他的业务逻辑（比如提交表单）就要使用编程式路由导航

路由传参问题：
    query、params两个属性可以传递参数
    query参数：不属于路径当中的一部分，类似于get请求，地址栏表现为 /search?k1=v1&k2=v2
    query参数对应的路由信息 path: "/search"
    params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位 ,地址栏表现为 /search/v1/v2
    params参数对应的路由信息要修改为path: "/search/:keyword" 这里的/:keyword就是一个params参数的占位符
    (params参数传参需要占位符)

Axios二次封装
    二次封装的具体方法在api文件夹下的request中

在api文件夹中的index.js中将api统一管理

访问后台接口要考虑跨域问题(面试会问)
    直接访问后台会出现访问的其实是前台服务器的问题
    使用proxy来解决跨域
    在vue.config.js配置跨域
    改动配置文件要重新运行项目

vuex状态管理库：
    集中式管理项目中公用的数据
    项目很多的情况下vuex能够很好的管理组件和数据
    
vuex实现模块式开发
    如果项目过多，数据过大，可以使用vuex实现模块式开发

vuex模块化开发需要store文件夹,index.js中引入vuex模块和子模块,设置state,mutations,actions,getters,并暴露和注册这些模块
    入口文件main.js要注册仓库,这样组件实例对象就有$store属性
    使用vuex的模块可以dispatch请求,然后用mapState获取数据

函数防抖与节流
    在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。
    安装lodash插件，该插件提供了防抖和节流的函数，我们可以引入js文件，直接调用。当然也可以自己写防抖和节流的函数

    防抖：用户操作很频繁，但是只执行一次，减少业务负担。
    节流：用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码

三级联动组件的路由跳转和传递参数（编程式导航+事件委托实现路由跳转）
    路由跳转的时候,如果使用声明式导航可能会出现卡顿现象，router-link会创建出大量的组件实例对象，对主机性能要求高，会出现卡顿现象，所以要用编程式导航
    但是假如直接给标签绑定点击事件回调函数，标签是循环创建的，每一个标签都绑定了一个独立的回调函数，性能也会受影响
    所以要用事件委派

事件委派（利用事件冒泡的原理）
    事件委派把全部的子节点的事件委派给父节点，但是要求点击a标签后才会进行路由跳转
    存在问题:1.如何确定点击的是a标签
            2.如何确定点击的是哪一级标签
    解决方法：添加一个自定义属性，属性值为标签名
            在回调函数参数中有event表示点击的对象，存储有对象信息

过渡动画
    vue中封装有过渡动画
    <transition></transition>

路由销毁问题
    Vue在路由切换的时候会销毁旧路由。
    我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据。
    由于Vue在路由切换的时候会销毁旧路由，当我们再次使用三级列表全局组件时还会发一次请求。
    如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。
    由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次）
    注意：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。

mock插件构造虚拟数据
    mock用来拦截前端ajax请求，返回我么们自定义的数据用于测试前端接口
    将不同的数据类型封装为不同的json文件，创建mockServer.js文件
    banner、floor分别为轮播图和页面底部的假数据。
    mock使用：1 src下创建mock文件夹 2 准备json数据 3 把需要的图片放在public文件夹中【public中文件打包的时候会原封不动的放在disc中】4 通过mock.js实现，创建mockServer.js实现模拟数据 5 在入口文件中引入mockServer.js
    接下来按照以往的操作，将api生成一个新的mockRequest.js（只改路径），在index中编写请求数据函数，在store中调用，通过actions-》mutations-》stste存到仓库中，在组件中使用...mapState函数让组件获取仓库中的数据

swiper基本使用
    swiper中文文档有:
        安装swiper
        在需要使用轮播图的组件内导入swpier和它的css样式
        在组件中创建swiper需要的dom标签（html代码，参考官网代码）
        创建swiper实例
    在new swiper实例前，网页必须要有现成的结构

    在创建swiper对象时，我们会传递一个参数用于获取展示轮播图的DOM元素，官网直接通过class（而且这个class不能修改，是swiper的css文件自带的）获取。但是这样有缺点：当页面中有多个轮播图时，因为它们使用了相同的class修饰的DOM，就会出现所有的swiper使用同样的数据，这肯定不是我们希望看到的。
    解决方法：在轮播图最外层DOM中添加ref属性
    <div class="swiper-container" id="mySwiper" ref="cur">
    通过ref属性值获取DOM

    初始化swiper不能在mounted中初始化，我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。
        解决方法：1 在updated中初始化轮播图，但是会有问题,如果组件中有其他数据响应的时候，该函数仍然触发
                2.延时器，但是肯定不好
                3 watch属性监听bannerList，发生变化就执行轮播图
                    即使这样也还是无法实现轮播图，原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片（因为swiper对象生效的前提是html即dom结构已经渲染好了）
                4 使用watch+this.$nextTick()（最完美）
                    this. $nextTick它会将回调延迟到下次 DOM 更新循环之后执行（循环就是这里的v-for）
                    无非是等我们页面中的结构都有了再去执行回调函数
    
vue本身的要点是减少对于dom的操作，尽量使用vue的方法 vm.$refs.refName 而不是document.getElementById()

组件可以复用

组件间通信（常见）：
    props：用于父子组件间通信
    自定义事件：@on @emit 子给父通信
    全局事件总线：$bus 全能
    pubsub：
    插槽：
    vuex

把首页中的轮播图拆分成公用全局的组件，这样可以方便使用，组件放在components文件夹

search模块开发
    1.静态页面
    2.发请求
    3.vuex仓库
    4.组件动态展示数据

axios post 传参需要传参，data:{} 里面是参数

vuex中的getters是计算属性，是为了简化数据而生

Object.assign实现对象拷贝

