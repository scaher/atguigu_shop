在编写路由组件前要先配置路由，在router文件夹中的index.js编写

路由组件与非路由组件区别：
    非路由组件放在components中，路由组件放在pages或views中
    非路由组件通过标签使用，路由组件通过路由使用
    在main.js注册玩路由，所有的路由和非路由组件身上都会拥有$router $route属性
    $router：一般进行编程式导航进行路由跳转
    $route： 一般获取路由信息（name path params等）

路由跳转有两种：
    声明式导航和编程式导航
    声明式路由导航通过<router-link></router-link>标签进行跳转，to属性设置跳转地址，tag属性设置解析模板时解析的标签，默认解析成a标签
    编程式路由导航通过js代码实现路由跳转，常用：
        this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)   ==>> 队列的方式（先进先出）
        this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)    ==>> 栈的方式（先进后出）
    当在跳转时要实现其他的业务逻辑（比如提交表单）就要使用编程式路由导航

路由传参问题：
    query、params两个属性可以传递参数
    query参数：不属于路径当中的一部分，类似于get请求，地址栏表现为 /search?k1=v1&k2=v2
    query参数对应的路由信息 path: "/search"
    params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位 ,地址栏表现为 /search/v1/v2
    params参数对应的路由信息要修改为path: "/search/:keyword" 这里的/:keyword就是一个params参数的占位符
    (params参数传参需要占位符)

Axios二次封装
    二次封装的具体方法在api文件夹下的request中

在api文件夹中的index.js中将api统一管理

访问后台接口要考虑跨域问题(面试会问)
    直接访问后台会出现访问的其实是前台服务器的问题
    使用proxy来解决跨域
    在vue.config.js配置跨域
    改动配置文件要重新运行项目

vuex状态管理库：
    集中式管理项目中公用的数据
    项目很多的情况下vuex能够很好的管理组件和数据
    
vuex实现模块式开发
    如果项目过多，数据过大，可以使用vuex实现模块式开发

vuex模块化开发需要store文件夹,index.js中引入vuex模块和子模块,设置state,mutations,actions,getters,并暴露和注册这些模块
    入口文件main.js要注册仓库,这样组件实例对象就有$store属性
    使用vuex的模块可以dispatch请求,然后用mapState获取数据

函数防抖与节流
    在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。
    安装lodash插件，该插件提供了防抖和节流的函数，我们可以引入js文件，直接调用。当然也可以自己写防抖和节流的函数

    防抖：用户操作很频繁，但是只执行一次，减少业务负担。
    节流：用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码

三级联动组件的路由跳转和传递参数（编程式导航+事件委托实现路由跳转）
    路由跳转的时候,如果使用声明式导航可能会出现卡顿现象，router-link会创建出大量的组件实例对象，对主机性能要求高，会出现卡顿现象，所以要用编程式导航
    但是假如直接给标签绑定点击事件回调函数，标签是循环创建的，每一个标签都绑定了一个独立的回调函数，性能也会受影响
    所以要用事件委派

事件委派（利用事件冒泡的原理）
    事件委派把全部的子节点的事件委派给父节点，但是要求点击a标签后才会进行路由跳转
    存在问题:1.如何确定点击的是a标签
            2.如何确定点击的是哪一级标签
    解决方法：添加一个自定义属性，属性值为标签名
            在回调函数参数中有event表示点击的对象，存储有对象信息

过渡动画
    vue中封装有过渡动画
    <transition></transition>

路由销毁问题
    Vue在路由切换的时候会销毁旧路由。
    我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据。
    由于Vue在路由切换的时候会销毁旧路由，当我们再次使用三级列表全局组件时还会发一次请求。
    如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。
    由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次）
    注意：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。

mock插件构造虚拟数据
    mock用来拦截前端ajax请求，返回我么们自定义的数据用于测试前端接口
    将不同的数据类型封装为不同的json文件，创建mockServer.js文件
    banner、floor分别为轮播图和页面底部的假数据。
    mock使用：1 src下创建mock文件夹 2 准备json数据 3 把需要的图片放在public文件夹中【public中文件打包的时候会原封不动的放在disc中】4 通过mock.js实现，创建mockServer.js实现模拟数据 5 在入口文件中引入mockServer.js
